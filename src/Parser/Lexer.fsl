{

// Opens methods related to fslex.exe
open FSharp.Text.Lexing

let newline (lexbuf: LexBuffer<_>) = 
  lexbuf.EndPos <- lexbuf.StartPos.NextLine
let lexeme = LexBuffer<_>.LexemeString
open Parser.Parser
let keywords =
    [
        "_", UNDER_BAR;
        "\\", LAMBDA;
        "lambda", LAMBDA;
        "open", OPEN;
        "import", IMPORT;
        "module", MODULE;
        "public", PUBLIC;
        "refl_", REFL;
    ] |> Map.ofList
let mutable acceptIndent = false
let mutable indents: int list = []
let mutable curerntIndent = 0
let mutable newlinesymbol = false
}
// Regular expressions
let whitespace = [' ']
let newline = ('\n' | '\r' | "\r\n")
let identChar = [^'\n' '\r' '\n' ' ' '\t' '.' '(' ')' '=' ':' ',' '⇒' '→' 'λ' '.' '{' '}' ';']
let identHead = [^'\n' '\r' '\n' ' ' '\t' '.' '(' ')' '=' ':' ',' '⇒' '→' 'λ' '.' '{' '}' ';']
let identTail = [^'\n' '\r' '\n' ' ' '\t' '.' '(' ')' '=' ':' ',' '⇒' '→' 'λ' '.' '{' '}' ';']
let ident = identHead | (identHead identChar* identTail)
let indent = whiltespace whitespace
let never = 'a'+'a'
rule start = parse
  | never? {
        if newlinesymbol then
          newlinesymbol <- false
          SEMICOLON
        else
        match curerntIndent with
        | 0 -> 
          tokenstream lexbuf 
        | n ->
          curerntIndent <- curerntIndent - 1
          BLOCKEND
    }
and tokenstream = parse
  // --------------------------
  | "." {Parser.DOT}
  // --------------------------
  | "(" {LPAREN}
  | ")" {RPAREN}
  | "=" {EQ}
  | ":" {COLON}
  | ";" {SEMICOLON}
  | "," {COMMA}
  | "→" {ARROW}
  | "⇒" {DARROW}
  | "=>" {DARROW}
  | "->" {ARROW}
  | "λ" {LAMBDA}
  | "." {DOT}
  | "*" {STAR}
  | "∗" {STAR}
  | "□" {RECT}
  | "{" {BLOCKBEGIN}
  | "}" {BLOCKEND}
  | "where" {
    acceptIndent <- true
    WHERE}
  | whitespace	{
    start lexbuf}
  | newline	whitespace* { 
    newline lexbuf
    let depth = (lexeme lexbuf).Length - 1
    let rec loop i indents =
      match indents with
      | [] -> i, []
      | x::xs -> 
        if depth < x then
          loop (i+1) xs
        else
          i, indents
    if acceptIndent then
      acceptIndent <- false
      printfn "%O" (depth, indents, curerntIndent)
      match indents with
      | x::xs ->
        if depth > x then
          indents <- depth :: indents
          BLOCKBEGIN
        else
          let (i, ls) = loop 1 xs
          indents <- ls
          curerntIndent <- i
          start lexbuf
      | [] ->
        printfn "a"
        indents <- [depth]
        BLOCKBEGIN
    else
      newlinesymbol <- true
      let (i, ls) = loop 0 indents
      indents <- ls
      curerntIndent <- i
      start lexbuf}
  | ident {
    match keywords.TryFind(lexeme lexbuf) with
                  | Some(token) -> token
                  | None -> IDENT(lexeme lexbuf)
  }
  // --------------------------
  | _    		{ failwith ("ParseError" + LexBuffer<_>.LexemeString lexbuf) }
  | eof   	{ Parser.EOF }